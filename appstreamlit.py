# -*- coding: utf-8 -*-
"""AppStreamlit.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Uuq7HGTUnIvDpIKGXN_xVzPMnnkopNSO
"""

import streamlit as st
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import OneHotEncoder, StandardScaler
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.ensemble import RandomForestRegressor
from sklearn.feature_selection import SelectFromModel
from sklearn.metrics import r2_score, mean_absolute_error

st.set_page_config(page_title="Predi√ß√£o de Pre√ßo", layout="wide")
st.title("üèéÔ∏è Sistema de Precifica√ß√£o de Carros")
st.markdown("Utilizando *Random Forest* e *Pipelines* do Scikit-Learn")

@st.cache_data
def carregar_dados():
    try:
        df = pd.read_csv("CarPrice_Assignment.csv")
        df["CarBrand"] = df["CarName"].apply(lambda x: x.split(" ")[0])
        df["avg_mpg"] = (df["citympg"] + df["highwaympg"]) / 2
        df["power_per_engine"] = df["horsepower"] / df["enginesize"]
        return df
    except FileNotFoundError:
        return None

@st.cache_resource
def treinar_modelo(df):
    y = np.log1p(df["price"])
    X = df.drop(columns=["price", "CarName"])
    cat_features = X.select_dtypes(include="object").columns.tolist()
    num_features = X.select_dtypes(exclude="object").columns.tolist()
    preprocessor = ColumnTransformer(
        transformers=[
            ("num", StandardScaler(), num_features),
            ("cat", OneHotEncoder(handle_unknown="ignore"), cat_features)
        ]
    )

    pipeline = Pipeline(
        steps=[
            ("preprocess", preprocessor),
            ("feature_selection", SelectFromModel(
                RandomForestRegressor(n_estimators=100, max_depth=20, random_state=42, n_jobs=-1),
                threshold="median"
            )),
            ("model", RandomForestRegressor(
                n_estimators=300,
                max_depth=25,
                min_samples_split=3,
                min_samples_leaf=1,
                random_state=42,
                n_jobs=-1
            ))
        ]
    )
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.20, random_state=42)
    pipeline.fit(X_train, y_train)
    pred_log = pipeline.predict(X_test)
    pred = np.expm1(pred_log)
    y_test_real = np.expm1(y_test)
    r2 = r2_score(y_test_real, pred)
    mae = mean_absolute_error(y_test_real, pred)

    return pipeline, r2, mae, num_features, cat_features, X_train

df = carregar_dados()
if df is None:
    st.error("Arquivo 'CarPrice_Assignment.csv' n√£o encontrado na pasta.")
    st.stop()
with st.spinner('Treinando a IA (Random Forest)...'):
    pipeline, r2, mae, num_cols, cat_cols, X_exemplo = treinar_modelo(df)
tab1, tab2 = st.tabs(["Simulador de Pre√ßo", "M√©tricas do Modelo"])

with tab1:
    st.write("### Configure o Ve√≠culo")
    col1, col2, col3 = st.columns(3)
    with col1:
        st.subheader("Motor e Pot√™ncia")
        horsepower = st.number_input("Cavalos (Horsepower)", 50, 500, 120)
        enginesize = st.number_input("Tamanho do Motor (cu in)", 50, 400, 150)
        fueltype = st.selectbox("Combust√≠vel", df['fueltype'].unique())
    with col2:
        st.subheader("Dimens√µes e Carroceria")
        carbody = st.selectbox("Tipo de Carroceria", df['carbody'].unique())
        drivewheel = st.selectbox("Tra√ß√£o", df['drivewheel'].unique())
        curbweight = st.slider("Peso do Carro (lbs)", 1500, 5000, 2500)
    with col3:
        st.subheader("Consumo e Marca")
        citympg = st.number_input("Consumo Cidade (mpg)", 10, 60, 25)
        highwaympg = st.number_input("Consumo Estrada (mpg)", 10, 60, 30)
        brand_list = sorted(df['CarBrand'].unique())
        marca = st.selectbox("Marca", brand_list)
    with st.expander("Detalhes T√©cnicos Avan√ßados (Opcional)"):
        c_tec1, c_tec2 = st.columns(2)
        with c_tec1:
            wheelbase = st.number_input("Entre-eixos (Wheelbase)", 80.0, 130.0, 98.0)
            carlength = st.number_input("Comprimento", 140.0, 210.0, 175.0)
            carwidth = st.number_input("Largura", 60.0, 85.0, 66.0)
        with c_tec2:
            boreratio = st.number_input("Bore Ratio", 2.0, 4.0, 3.30)
            stroke = st.number_input("Stroke", 2.0, 5.0, 3.20)
            compression = st.number_input("Taxa de Compress√£o", 7.0, 25.0, 9.0)

    if st.button("Calcular Pre√ßo", type="primary"):
        input_dict = {
            'horsepower': horsepower,
            'enginesize': enginesize,
            'fueltype': fueltype,
            'carbody': carbody,
            'drivewheel': drivewheel,
            'curbweight': curbweight,
            'citympg': citympg,
            'highwaympg': highwaympg,
            'CarBrand': marca,
            'wheelbase': wheelbase,
            'carlength': carlength,
            'carwidth': carwidth,
            'boreratio': boreratio,
            'stroke': stroke,
            'compressionratio': compression,
            'symboling': 0,
            'carheight': 54.0,
            'peakrpm': 5000,
            'aspiration': 'std',
            'doornumber': 'four',
            'enginelocation': 'front',
            'enginetype': 'ohc',
            'cylindernumber': 'four',
            'fuelsystem': 'mpfi'
        }

        df_input = pd.DataFrame([input_dict])
        df_input["avg_mpg"] = (df_input["citympg"] + df_input["highwaympg"]) / 2
        df_input["power_per_engine"] = df_input["horsepower"] / df_input["enginesize"]
        for col in num_cols:
            if col not in df_input.columns:
                df_input[col] = 0
        for col in cat_cols:
            if col not in df_input.columns:
                df_input[col] = "unknown"
        log_pred = pipeline.predict(df_input)
        price_pred = np.expm1(log_pred)[0]
        st.success(f"### Pre√ßo Estimado: $ {price_pred:,.2f}")
        st.info("Nota: O modelo considera caracter√≠sticas t√©cnicas e a marca para estimar o valor.")
with tab2:
    st.header("Performance do Random Forest")
    m1, m2 = st.columns(2)
    m1.metric("R¬≤ Score (Precis√£o)", f"{r2:.4f}")
    m2.metric("Erro M√©dio Absoluto (MAE)", f"$ {mae:.2f}")

    st.markdown("""
    **Por que este modelo √© melhor?**
    * **Sele√ß√£o de Features:** O algoritmo escolheu automaticamente as caracter√≠sticas mais importantes.
    * **Random Forest:** Cria centenas de √°rvores de decis√£o para evitar erros de um √∫nico modelo.
    * **Pipeline:** Garante que os dados novos passem pelo mesmo tratamento matem√°tico dos dados de treino.
    """)