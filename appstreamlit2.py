# -*- coding: utf-8 -*-
"""AppStreamlit2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1unoqBWDQKjQLaFlRV9yHGoR1JTTaeSrR
"""

import streamlit as st
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import OneHotEncoder, StandardScaler
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import r2_score, mean_absolute_error

st.set_page_config(page_title="Predi√ß√£o de Pre√ßo", layout="wide")
st.title("üèéÔ∏è Sistema de Precifica√ß√£o de Carros ‚Äî Vers√£o 2")
st.markdown("Modelo aprimorado com **novas features**, **√°rvores mais profundas** e **melhor generaliza√ß√£o**.")

@st.cache_data
def carregar_dados():
    df = pd.read_csv("CarPrice_Assignment.csv")
    df["CarBrand"] = df["CarName"].apply(lambda x: x.split(" ")[0])
    df["avg_mpg"] = (df["citympg"] + df["highwaympg"]) / 2
    df["power_per_engine"] = df["horsepower"] / df["enginesize"]
    df["hp_per_weight"] = df["horsepower"] / df["curbweight"]
    df["torque_est"] = df["enginesize"] * df["compressionratio"]

    return df

@st.cache_resource
def treinar_modelo(df):
    y = np.log1p(df["price"])
    X = df.drop(columns=["price", "CarName"])
    cat_features = X.select_dtypes(include="object").columns.tolist()
    num_features = X.select_dtypes(exclude="object").columns.tolist()
    preprocessor = ColumnTransformer(
        transformers=[
            ("num", StandardScaler(), num_features),
            ("cat", OneHotEncoder(handle_unknown="ignore"), cat_features)
        ]
    )
    model = RandomForestRegressor(
        n_estimators=600,
        max_depth=None,
        min_samples_split=2,
        min_samples_leaf=1,
        random_state=42,
        n_jobs=-1
    )
    pipeline = Pipeline(
        steps=[
            ("preprocess", preprocessor),
            ("model", model)
        ]
    )
    X_train, X_test, y_train, y_test = train_test_split(
        X, y, test_size=0.20, shuffle=True, random_state=42
    )
    pipeline.fit(X_train, y_train)
    pred_log = pipeline.predict(X_test)
    pred = np.expm1(pred_log)
    y_test_real = np.expm1(y_test)
    r2 = r2_score(y_test_real, pred)
    mae = mean_absolute_error(y_test_real, pred)

    return pipeline, r2, mae, num_features, cat_features, X_train

df = carregar_dados()
pipeline, r2, mae, num_cols, cat_cols, X_example = treinar_modelo(df)
tab1, tab2 = st.tabs(["Simulador de Pre√ßo", "M√©tricas do Modelo"])
with tab1:
    st.write("### Configure o ve√≠culo abaixo para estimar seu valor:")
    col1, col2, col3 = st.columns(3)
    with col1:
        horsepower = st.number_input("Cavalos (HP)", 50, 500, 120)
        enginesize = st.number_input("Tamanho do Motor", 50, 400, 150)
        fueltype = st.selectbox("Combust√≠vel", df["fueltype"].unique())
    with col2:
        carbody = st.selectbox("Carroceria", df["carbody"].unique())
        drivewheel = st.selectbox("Tra√ß√£o", df["drivewheel"].unique())
        curbweight = st.slider("Peso (lbs)", 1500, 5000, 2500)
    with col3:
        citympg = st.number_input("Cidade (mpg)", 10, 60, 25)
        highwaympg = st.number_input("Estrada (mpg)", 10, 60, 30)
        marca = st.selectbox("Marca", sorted(df["CarBrand"].unique()))
    with st.expander("Detalhes t√©cnicos (opcional)"):
        wheelbase = st.number_input("Wheelbase", 80.0, 130.0, 98.0)
        carlength = st.number_input("Comprimento", 140.0, 210.0, 175.0)
        carwidth = st.number_input("Largura", 60.0, 85.0, 66.0)
        boreratio = st.number_input("Bore Ratio", 2.0, 4.0, 3.30)
        stroke = st.number_input("Stroke", 2.0, 5.0, 3.20)
        compression = st.number_input("Compress√£o", 7.0, 25.0, 9.0)
    if st.button("Calcular Pre√ßo", type="primary"):
        input_dict = {
            "horsepower": horsepower,
            "enginesize": enginesize,
            "fueltype": fueltype,
            "carbody": carbody,
            "drivewheel": drivewheel,
            "curbweight": curbweight,
            "citympg": citympg,
            "highwaympg": highwaympg,
            "CarBrand": marca,
            "wheelbase": wheelbase,
            "carlength": carlength,
            "carwidth": carwidth,
            "boreratio": boreratio,
            "stroke": stroke,
            "compressionratio": compression,
            "symboling": 0,
            "carheight": 54.0,
            "peakrpm": 5000,
            "aspiration": "std",
            "doornumber": "four",
            "enginelocation": "front",
            "enginetype": "ohc",
            "cylindernumber": "four",
            "fuelsystem": "mpfi"
        }

        df_input = pd.DataFrame([input_dict])
        df_input["avg_mpg"] = (df_input["citympg"] + df_input["highwaympg"]) / 2
        df_input["power_per_engine"] = df_input["horsepower"] / df_input["enginesize"]
        df_input["hp_per_weight"] = df_input["horsepower"] / df_input["curbweight"]
        df_input["torque_est"] = df_input["enginesize"] * df_input["compressionratio"]
        for col in num_cols:
            if col not in df_input.columns:
                df_input[col] = 0
        for col in cat_cols:
            if col not in df_input.columns:
                df_input[col] = "unknown"
        log_pred = pipeline.predict(df_input)
        price_pred = np.expm1(log_pred)[0]
        st.success(f"### Pre√ßo Estimado: **$ {price_pred:,.2f}**")
with tab2:
    st.header("Desempenho do Modelo (Random Forest v2)")
    c1, c2 = st.columns(2)
    c1.metric("R¬≤", f"{r2:.4f}")
    c2.metric("MAE", f"$ {mae:,.2f}")

    st.markdown("""
    ### Melhorias desta vers√£o:
    - √Årvores mais profundas (captura melhor esportivos)
    - Remo√ß√£o do SelectFromModel (antes descartava features importantes)
    - Novas features de performance:
        * horsepower / enginesize
        * horsepower / peso
        * torque estimado
    - Pipeline mais est√°vel
    - Melhor generaliza√ß√£o
    """)