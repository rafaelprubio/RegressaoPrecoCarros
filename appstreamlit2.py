# -*- coding: utf-8 -*-
"""AppStreamlit2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1unoqBWDQKjQLaFlRV9yHGoR1JTTaeSrR
"""

import streamlit as st
import pandas as pd
import numpy as np
from sklearn.base import BaseEstimator, TransformerMixin
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.preprocessing import OneHotEncoder, StandardScaler
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import r2_score, mean_absolute_error, mean_squared_error

st.set_page_config(page_title="Predi√ß√£o de Pre√ßo de Carros", layout="wide")
st.title("üèéÔ∏è Sistema de Precifica√ß√£o de Carros")
st.markdown("Utilizando **Random Forest**")

class FeatureEngineer(BaseEstimator, TransformerMixin):
    def fit(self, X, y=None):
        return self
    def transform(self, X):
        X = X.copy()
        X["avg_mpg"] = (X["citympg"] + X["highwaympg"]) / 2
        X["power_per_engine"] = X["horsepower"] / (X["enginesize"] + 1)
        X["power_to_weight"] = X["horsepower"] / (X["curbweight"] + 1) * 1000
        X["is_lightweight_powerful"] = (
            (X["curbweight"] < 2500) & (X["horsepower"] > 150)
        ).astype(int)
        X["is_premium"] = (
            (X["curbweight"] > 3000) & (X["horsepower"] > 140)
        ).astype(int)
        X["car_size"] = X["carlength"] * X["carwidth"]
        X["engine_efficiency"] = X["horsepower"] / (X["compressionratio"] + 1)
        X["brand_body"] = X["CarBrand"] + "_" + X["carbody"]
        X["power_category"] = pd.cut(
            X["horsepower"],
            bins=[0, 80, 120, 180, 500],
            labels=["low", "mid", "high", "extreme"]
        ).astype(str)
        # Cria√ß√£o de flags para identificar carros diferentes (esportivos potentes e leves por ex.)

        return X

@st.cache_data
def carregar_e_limpar_dados():
    try:
        df = pd.read_csv("CarPrice_Assignment.csv")
        brand_fixes = {
            'maxda': 'mazda',
            'porcshce': 'porsche',
            'toyouta': 'toyota',
            'vokswagen': 'volkswagen',
            'vw': 'volkswagen',
            'alfa-romero': 'alfa-romeo'
        }
        df["CarBrand"] = df["CarName"].str.split().str[0].str.lower()
        df["CarBrand"] = df["CarBrand"].replace(brand_fixes)
        df = df[df["price"] <= df["price"].quantile(0.99)]
        df = df.dropna()
        return df
    except FileNotFoundError:
        return None

@st.cache_resource
def treinar_modelo(df):
    y = np.log1p(df["price"])
    X = df.drop(columns=["price", "CarName", "car_ID"])
    base_num_features = [
        'symboling', 'wheelbase', 'carlength', 'carwidth', 'carheight',
        'curbweight', 'enginesize', 'boreratio', 'stroke', 'compressionratio',
        'horsepower', 'peakrpm', 'citympg', 'highwaympg'
    ]
    base_cat_features = [
        'fueltype', 'aspiration', 'doornumber', 'carbody', 'drivewheel',
        'enginelocation', 'enginetype', 'cylindernumber', 'fuelsystem', 'CarBrand'
    ]
    engineered_num = [
        'avg_mpg', 'power_per_engine', 'power_to_weight',
        'is_lightweight_powerful', 'is_premium', 'car_size', 'engine_efficiency'
    ]
    engineered_cat = ['brand_body', 'power_category']
    all_num = base_num_features + engineered_num
    all_cat = base_cat_features + engineered_cat

    preprocessor = ColumnTransformer(
        transformers=[
            ("num", StandardScaler(), all_num),
            ("cat", OneHotEncoder(handle_unknown="ignore", sparse_output=False), all_cat)
        ],
        remainder='drop'
    )
    pipeline = Pipeline([
        ("feature_engineering", FeatureEngineer()),
        ("preprocessing", preprocessor),
        ("model", RandomForestRegressor(
            n_estimators=200,
            max_depth=15,
            min_samples_split=5,
            min_samples_leaf=2,
            max_features='sqrt',
            random_state=42,
            n_jobs=-1
        ))
    ])
    X_train, X_test, y_train, y_test = train_test_split(
        X, y, test_size=0.20, random_state=42
    )
    pipeline.fit(X_train, y_train)
    pred_log = pipeline.predict(X_test)
    pred = np.expm1(pred_log)
    y_test_real = np.expm1(y_test)
    r2 = r2_score(y_test_real, pred)
    mae = mean_absolute_error(y_test_real, pred)
    rmse = np.sqrt(mean_squared_error(y_test_real, pred))
    cv_scores = cross_val_score(
        pipeline, X, y, cv=5, scoring='r2', n_jobs=-1
    )
    return pipeline, r2, mae, rmse, cv_scores, base_num_features, base_cat_features

df = carregar_e_limpar_dados()
if df is None:
    st.error("Dataset n√£o encontrado na pasta.")
    st.stop()

with st.spinner('Treinando a IA com Random Forest...'):
    pipeline, r2, mae, rmse, cv_scores, num_cols, cat_cols = treinar_modelo(df)
st.success("Modelo treinado com sucesso!")
tab1, tab2, tab3 = st.tabs(["Simulador de Pre√ßo", "M√©tricas do Modelo", "An√°lise de Features"])

with tab1:
    st.write("### Configure o Ve√≠culo")
    col1, col2, col3 = st.columns(3)
    with col1:
        st.subheader("Motor e Pot√™ncia")
        horsepower = st.number_input("Cavalos (HP)", 50, 500, 120)
        enginesize = st.number_input("Tamanho do Motor (cu in)", 50, 400, 150)
        fueltype = st.selectbox("Combust√≠vel", df['fueltype'].unique())
        cylindernumber = st.selectbox("N√∫mero de Cilindros", df['cylindernumber'].unique())
    with col2:
        st.subheader("Dimens√µes e Carroceria")
        carbody = st.selectbox("Tipo de Carroceria", df['carbody'].unique())
        drivewheel = st.selectbox("Tra√ß√£o", df['drivewheel'].unique())
        curbweight = st.slider("Peso do Carro (lbs)", 1500, 5000, 2500)
        doornumber = st.selectbox("N√∫mero de Portas", df['doornumber'].unique())
    with col3:
        st.subheader("Consumo e Marca")
        citympg = st.number_input("Consumo Cidade (mpg)", 10, 60, 25)
        highwaympg = st.number_input("Consumo Estrada (mpg)", 10, 60, 30)
        brand_list = sorted(df['CarBrand'].unique())
        marca = st.selectbox("Marca", brand_list)
        aspiration = st.selectbox("Aspira√ß√£o", df['aspiration'].unique())
    with st.expander("Detalhes T√©cnicos Avan√ßados"):
        c_tec1, c_tec2, c_tec3 = st.columns(3)
        with c_tec1:
            wheelbase = st.number_input("Entre-eixos", 80.0, 130.0, 98.0)
            carlength = st.number_input("Comprimento", 140.0, 210.0, 175.0)
            carwidth = st.number_input("Largura", 60.0, 85.0, 66.0)
            carheight = st.number_input("Altura", 45.0, 65.0, 54.0)
        with c_tec2:
            boreratio = st.number_input("Bore Ratio", 2.0, 4.0, 3.30)
            stroke = st.number_input("Stroke", 2.0, 5.0, 3.20)
            compression = st.number_input("Taxa de Compress√£o", 7.0, 25.0, 9.0)
            peakrpm = st.number_input("RPM M√°ximo", 4000, 7000, 5000)
        with c_tec3:
            enginetype = st.selectbox("Tipo de Motor", df['enginetype'].unique())
            fuelsystem = st.selectbox("Sistema de Combust√≠vel", df['fuelsystem'].unique())
            enginelocation = st.selectbox("Localiza√ß√£o do Motor", df['enginelocation'].unique())
            symboling = st.selectbox("Simboling (Risco)", df['symboling'].unique())
    st.markdown("---")
    if st.button("Calcular Pre√ßo Estimado", type="primary", use_container_width=True):
        input_dict = {
            'symboling': symboling,
            'fueltype': fueltype,
            'aspiration': aspiration,
            'doornumber': doornumber,
            'carbody': carbody,
            'drivewheel': drivewheel,
            'enginelocation': enginelocation,
            'wheelbase': wheelbase,
            'carlength': carlength,
            'carwidth': carwidth,
            'carheight': carheight,
            'curbweight': curbweight,
            'enginetype': enginetype,
            'cylindernumber': cylindernumber,
            'enginesize': enginesize,
            'fuelsystem': fuelsystem,
            'boreratio': boreratio,
            'stroke': stroke,
            'compressionratio': compression,
            'horsepower': horsepower,
            'peakrpm': peakrpm,
            'citympg': citympg,
            'highwaympg': highwaympg,
            'CarBrand': marca,
            'car_ID': 0
        }
        df_input = pd.DataFrame([input_dict])
        log_pred = pipeline.predict(df_input)
        price_pred = np.expm1(log_pred)[0]
        power_to_weight = horsepower / curbweight * 1000
        avg_mpg = (citympg + highwaympg) / 2
        st.markdown("---")
        col_result1, col_result2 = st.columns([2, 1])
        with col_result1:
            st.success(f"### Pre√ßo Estimado: **${price_pred:,.2f}**")
            if price_pred < 10000:
                st.info("**Categoria**: Ve√≠culo Econ√¥mico")
            elif price_pred < 20000:
                st.info("**Categoria**: Ve√≠culo Intermedi√°rio")
            elif price_pred < 30000:
                st.info("**Categoria**: Ve√≠culo Premium")
            else:
                st.info("**Categoria**: Ve√≠culo de Luxo/Esportivo")
        with col_result2:
            st.metric("Rela√ß√£o Pot√™ncia/Peso", f"{power_to_weight:.2f}")
            st.metric("Consumo M√©dio", f"{avg_mpg:.1f} mpg")

        st.caption("**Nota**: Esta √© uma estimativa baseada em dados antigos. O pre√ßo dos carros atuais √© maior.")

with tab2:
    st.header("Performance do Modelo Random Forest")
    col_m1, col_m2, col_m3 = st.columns(3)
    col_m1.metric("R¬≤ Score (Teste)", f"{r2:.4f}", help="Quanto maior, melhor (m√°ximo 1.0)")
    col_m2.metric("MAE (Erro M√©dio)", f"${mae:,.2f}", help="Erro m√©dio em d√≥lares")
    col_m3.metric("RMSE", f"${rmse:,.2f}", help="Raiz do erro quadr√°tico m√©dio")
    st.markdown("---")
    st.subheader("Valida√ß√£o Cruzada (5-Fold)")
    st.write(f"**R¬≤ M√©dio**: {cv_scores.mean():.4f} (¬± {cv_scores.std():.4f})")
    cv_df = pd.DataFrame({
        'Fold': range(1, 6),
        'R¬≤ Score': cv_scores
    })
    st.dataframe(cv_df, use_container_width=True)
    st.markdown("---")
    st.subheader("Melhorias Implementadas")
    col_imp1, col_imp2 = st.columns(2)

    with col_imp1:
        st.markdown("""
        - Rela√ß√£o pot√™ncia/peso (crucial para esportivos)
        - Flags para carros leves e potentes
        - Intera√ß√£o marca √ó tipo de carroceria
        - Categoria de pot√™ncia
        - Tamanho do ve√≠culo (√°rea)
        """)

    st.info("""
    **Por que o modelo anterior falhava com esportivos?**

    O problema era que o modelo aprendia: *"peso baixo = pre√ßo baixo"* (verdade para carros populares).
    Mas em esportivos, leveza √© premium! A nova feature **pot√™ncia/peso** resolve isso.
    """)

with tab3:
    st.header("An√°lise de Import√¢ncia das Features")
    feature_names = pipeline.named_steps['preprocessing'].get_feature_names_out()
    importances = pipeline.named_steps['model'].feature_importances_
    feature_importance_df = pd.DataFrame({
        'Feature': feature_names,
        'Import√¢ncia': importances
    }).sort_values('Import√¢ncia', ascending=False).head(20)
    st.subheader("Top 20 Features Mais Importantes")
    st.dataframe(feature_importance_df, use_container_width=True)
    st.markdown("---")
    st.subheader("Estat√≠sticas do Dataset")
    col_stat1, col_stat2, col_stat3, col_stat4 = st.columns(4)
    col_stat1.metric("Total de Carros", len(df))
    col_stat2.metric("Pre√ßo M√©dio", f"${df['price'].mean():,.2f}")
    col_stat3.metric("Pre√ßo M√≠nimo", f"${df['price'].min():,.2f}")
    col_stat4.metric("Pre√ßo M√°ximo", f"${df['price'].max():,.2f}")
    st.markdown("---")
    st.subheader("Distribui√ß√£o por Marca")
    brand_counts = df['CarBrand'].value_counts().head(10)
    st.bar_chart(brand_counts)

st.markdown("---")
st.caption("Sistema desenvolvido com Scikit-Learn | Random Forest Regressor")