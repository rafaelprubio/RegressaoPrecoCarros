# -*- coding: utf-8 -*-
"""AppStreamlit2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1unoqBWDQKjQLaFlRV9yHGoR1JTTaeSrR
"""

import streamlit as st
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import OneHotEncoder, StandardScaler
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.ensemble import RandomForestRegressor
from sklearn.feature_selection import SelectFromModel
from sklearn.metrics import r2_score, mean_absolute_error, mean_squared_error
import matplotlib.pyplot as plt
import seaborn as sns

st.set_page_config(page_title="Predi√ß√£o de Pre√ßo de Carros", layout="wide", initial_sidebar_state="expanded")
st.title("üèéÔ∏è Sistema Inteligente de Precifica√ß√£o de Carros")
st.markdown("Utilizando **Random Forest** para estimativa de pre√ßos")

@st.cache_data
def carregar_e_limpar_dados():
    try:
        df = pd.read_csv("CarPrice_Assignment.csv")
        df["CarName"] = df["CarName"].str.strip().str.lower()
        df["CarBrand"] = df["CarName"].apply(lambda x: x.split(" ")[0] if isinstance(x, str) else "unknown")
        df["avg_mpg"] = (df["citympg"] + df["highwaympg"]) / 2
        df["power_per_engine"] = df["horsepower"] / df["enginesize"]
        df["volume"] = df["carlength"] * df["carwidth"] * df["carheight"]
        df["weight_to_power"] = df["curbweight"] / df["horsepower"]
        df = df.fillna(df.median(numeric_only=True))
        return df
    except FileNotFoundError:
        return None

@st.cache_resource
def treinar_modelo(df):
    y = np.log1p(df["price"])
    X = df.drop(columns=["price", "CarName", "car_ID"])
    cat_features = X.select_dtypes(include="object").columns.tolist()
    num_features = X.select_dtypes(exclude="object").columns.tolist()
    preprocessor = ColumnTransformer(
        transformers=[
            ("num", StandardScaler(), num_features),
            ("cat", OneHotEncoder(handle_unknown="ignore", sparse_output=False), cat_features)
        ]
    )
    pipeline = Pipeline(
        steps=[
            ("preprocess", preprocessor),
            ("feature_selection", SelectFromModel(
                RandomForestRegressor(n_estimators=100, max_depth=20, random_state=42, n_jobs=-1),
                threshold="median"
            )),
            ("model", RandomForestRegressor(
                n_estimators=300,
                max_depth=25,
                min_samples_split=3,
                min_samples_leaf=1,
                random_state=42,
                n_jobs=-1
            ))
        ]
    )
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.20, random_state=42)
    pipeline.fit(X_train, y_train)
    pred_log = pipeline.predict(X_test)
    pred = np.expm1(pred_log)
    y_test_real = np.expm1(y_test)
    r2 = r2_score(y_test_real, pred)
    mae = mean_absolute_error(y_test_real, pred)
    rmse = np.sqrt(mean_squared_error(y_test_real, pred))
    mape = np.mean(np.abs((y_test_real - pred) / y_test_real)) * 10
    return pipeline, r2, mae, rmse, mape, num_features, cat_features, X_train, y_test_real, pred

df = carregar_e_limpar_dados()
if df is None:
    st.error("Dataset n√£o encontrado na pasta.")
    st.stop()
with st.spinner('Treinando a IA (Random Forest)...'):
    pipeline, r2, mae, rmse, mape, num_cols, cat_cols, X_exemplo, y_test, y_pred = treinar_modelo(df)

with st.sidebar:
    st.header("Informa√ß√µes do Dataset")
    st.metric("Total de Carros", len(df))
    st.metric("Marcas √önicas", df['CarBrand'].nunique())
    st.metric("Faixa de Pre√ßos", f"${df['price'].min():.0f} - ${df['price'].max():.0f}")

    st.markdown("---")
    st.subheader("Performance do Modelo")
    st.metric("R¬≤ Score", f"{r2:.4f}")
    st.metric("Erro M√©dio (MAE)", f"${mae:.2f}")
    st.metric("Erro % M√©dio (MAPE)", f"{mape:.2f}%")

    st.markdown("---")
    st.markdown("### Sobre o Modelo")
    st.info("""
    Este sistema utiliza **Random Forest**, um algoritmo de aprendizado de m√°quina que:
    - Cria centenas de √°rvores de decis√£o
    - Considera m√∫ltiplas caracter√≠sticas simultaneamente
    - Evita overfitting atrav√©s de ensemble
    """)

tab1, tab2, tab3, tab4 = st.tabs(["Simulador de Pre√ßo", "M√©tricas do Modelo", "An√°lise Explorat√≥ria", "Sobre o Projeto"])

with tab1:
    st.write("### Configure o Ve√≠culo para Estimar o Pre√ßo")

    col1, col2, col3 = st.columns(3)

    with col1:
        st.subheader("Motor e Pot√™ncia")
        horsepower = st.number_input("Cavalos (Horsepower)", 50, 500, 120, help="Pot√™ncia do motor")
        enginesize = st.number_input("Tamanho do Motor (cu in)", 50, 400, 150)
        fueltype = st.selectbox("Combust√≠vel", df['fueltype'].unique())

    with col2:
        st.subheader("Dimens√µes e Carroceria")
        carbody = st.selectbox("Tipo de Carroceria", df['carbody'].unique())
        drivewheel = st.selectbox("Tra√ß√£o", df['drivewheel'].unique())
        curbweight = st.slider("Peso do Carro (lbs)", 1500, 5000, 2500)

    with col3:
        st.subheader("Consumo e Marca")
        citympg = st.number_input("Consumo Cidade (mpg)", 10, 60, 25)
        highwaympg = st.number_input("Consumo Estrada (mpg)", 10, 60, 30)
        brand_list = sorted(df['CarBrand'].unique())
        marca = st.selectbox("Marca", brand_list)

    with st.expander("Detalhes T√©cnicos Avan√ßados (Opcional)"):
        c_tec1, c_tec2, c_tec3 = st.columns(3)
        with c_tec1:
            wheelbase = st.number_input("Entre-eixos (Wheelbase)", 80.0, 130.0, 98.0)
            carlength = st.number_input("Comprimento", 140.0, 210.0, 175.0)
            carwidth = st.number_input("Largura", 60.0, 85.0, 66.0)
            carheight = st.number_input("Altura", 45.0, 65.0, 54.0)
        with c_tec2:
            aspiration = st.selectbox("Aspira√ß√£o", df['aspiration'].unique())
            doornumber = st.selectbox("N√∫mero de Portas", df['doornumber'].unique())
            boreratio = st.number_input("Bore Ratio", 2.0, 4.0, 3.30)
            stroke = st.number_input("Stroke", 2.0, 5.0, 3.20)
        with c_tec3:
            compression = st.number_input("Taxa de Compress√£o", 7.0, 25.0, 9.0)
            peakrpm = st.number_input("RPM M√°ximo", 3000, 7000, 5000)
            enginetype = st.selectbox("Tipo de Motor", df['enginetype'].unique())
            cylindernumber = st.selectbox("N√∫mero de Cilindros", df['cylindernumber'].unique())
        c_tec4, c_tec5 = st.columns(2)
        with c_tec4:
            fuelsystem = st.selectbox("Sistema de Combust√≠vel", df['fuelsystem'].unique())
        with c_tec5:
            enginelocation = st.selectbox("Localiza√ß√£o do Motor", df['enginelocation'].unique())

    if st.button("Calcular Pre√ßo Estimado", type="primary", use_container_width=True):
        input_dict = {
            'horsepower': horsepower,
            'enginesize': enginesize,
            'fueltype': fueltype,
            'carbody': carbody,
            'drivewheel': drivewheel,
            'curbweight': curbweight,
            'citympg': citympg,
            'highwaympg': highwaympg,
            'CarBrand': marca,
            'wheelbase': wheelbase,
            'carlength': carlength,
            'carwidth': carwidth,
            'carheight': carheight,
            'boreratio': boreratio,
            'stroke': stroke,
            'compressionratio': compression,
            'symboling': 0,
            'peakrpm': peakrpm,
            'aspiration': aspiration,
            'doornumber': doornumber,
            'enginelocation': enginelocation,
            'enginetype': enginetype,
            'cylindernumber': cylindernumber,
            'fuelsystem': fuelsystem
        }

        df_input = pd.DataFrame([input_dict])
        df_input["avg_mpg"] = (df_input["citympg"] + df_input["highwaympg"]) / 2
        df_input["power_per_engine"] = df_input["horsepower"] / df_input["enginesize"]
        df_input["volume"] = df_input["carlength"] * df_input["carwidth"] * df_input["carheight"]
        df_input["weight_to_power"] = df_input["curbweight"] / df_input["horsepower"]

        for col in num_cols:
            if col not in df_input.columns:
                df_input[col] = 0
        for col in cat_cols:
            if col not in df_input.columns:
                df_input[col] = "unknown"

        log_pred = pipeline.predict(df_input)
        price_pred = np.expm1(log_pred)[0]
        lower_bound = price_pred * 0.85
        upper_bound = price_pred * 1.15

        st.success(f"### Pre√ßo Estimado: ${price_pred:,.2f}")
        st.info(f"Faixa de Confian√ßa: ${lower_bound:,.2f} - ${upper_bound:,.2f}")
        similar_cars = df[(df['CarBrand'] == marca) & (df['carbody'] == carbody)]['price']
        if len(similar_cars) > 0:
            st.write(f"**Compara√ß√£o:** Carros similares da marca {marca.title()} custam em m√©dia ${similar_cars.mean():,.2f}")

with tab2:
    st.header("Performance e Valida√ß√£o do Modelo")

    col1, col2, col3, col4 = st.columns(4)
    col1.metric("R¬≤ Score", f"{r2:.4f}", help="Explica quanto da varia√ß√£o nos pre√ßos o modelo consegue prever")
    col2.metric("MAE (Erro M√©dio)", f"${mae:.2f}", help="Erro m√©dio em d√≥lares")
    col3.metric("RMSE", f"${rmse:.2f}", help="Penaliza erros maiores mais fortemente")
    col4.metric("MAPE", f"{mape:.2f}%", help="Erro percentual m√©dio")

    st.markdown("---")
    col_g1, col_g2 = st.columns(2)

    with col_g1:
        st.subheader("Predi√ß√µes vs Valores Reais")
        fig, ax = plt.subplots(figsize=(8, 6))
        ax.scatter(y_test, y_pred, alpha=0.6, edgecolors='k')
        ax.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'r--', lw=2)
        ax.set_xlabel('Pre√ßo Real ($)')
        ax.set_ylabel('Pre√ßo Predito ($)')
        ax.set_title('Qualidade das Predi√ß√µes')
        ax.grid(True, alpha=0.3)
        st.pyplot(fig)

    with col_g2:
        st.subheader("Distribui√ß√£o dos Erros")
        residuals = y_test - y_pred
        fig, ax = plt.subplots(figsize=(8, 6))
        ax.hist(residuals, bins=30, edgecolor='black', alpha=0.7)
        ax.axvline(0, color='red', linestyle='--', linewidth=2)
        ax.set_xlabel('Erro ($)')
        ax.set_ylabel('Frequ√™ncia')
        ax.set_title('Distribui√ß√£o dos Res√≠duos')
        ax.grid(True, alpha=0.3)
        st.pyplot(fig)

    st.markdown("""
    ### üéØ Por que este modelo √© robusto?

    1. **Pipeline Automatizado:** Garante consist√™ncia no pr√©-processamento
    2. **Sele√ß√£o de Features:** Identifica automaticamente as caracter√≠sticas mais importantes
    3. **Random Forest:** Usa 300 √°rvores de decis√£o para reduzir erros
    4. **Features Engenheiradas:** avg_mpg, power_per_engine, volume, weight_to_power

    ### Configura√ß√£o do Modelo
    - **Algoritmo:** Random Forest com 300 estimadores
    - **Profundidade m√°xima:** 25 n√≠veis
    - **Sele√ß√£o de features:** Threshold = mediana (remove 50% menos importantes)
    """)

with tab3:
    st.header("An√°lise Explorat√≥ria dos Dados")

    col_a1, col_a2 = st.columns(2)

    with col_a1:
        st.subheader("Top 10 Marcas por Pre√ßo M√©dio")
        top_brands = df.groupby('CarBrand')['price'].mean().sort_values(ascending=False).head(10)
        fig, ax = plt.subplots(figsize=(8, 6))
        top_brands.plot(kind='barh', ax=ax, color='steelblue')
        ax.set_xlabel('Pre√ßo M√©dio ($)')
        ax.set_title('Marcas Mais Caras')
        st.pyplot(fig)

    with col_a2:
        st.subheader("Distribui√ß√£o de Pre√ßos")
        fig, ax = plt.subplots(figsize=(8, 6))
        ax.hist(df['price'], bins=30, edgecolor='black', alpha=0.7, color='coral')
        ax.set_xlabel('Pre√ßo ($)')
        ax.set_ylabel('Frequ√™ncia')
        ax.set_title('Distribui√ß√£o dos Pre√ßos no Dataset')
        ax.axvline(df['price'].mean(), color='red', linestyle='--', linewidth=2, label='M√©dia')
        ax.legend()
        st.pyplot(fig)

    st.markdown("---")

    col_a3, col_a4 = st.columns(2)

    with col_a3:
        st.subheader("Pre√ßo por Tipo de Carroceria")
        body_price = df.groupby('carbody')['price'].mean().sort_values(ascending=False)
        fig, ax = plt.subplots(figsize=(8, 6))
        body_price.plot(kind='bar', ax=ax, color='teal')
        ax.set_ylabel('Pre√ßo M√©dio ($)')
        ax.set_title('Tipo de Carroceria vs Pre√ßo')
        plt.xticks(rotation=45)
        st.pyplot(fig)

    with col_a4:
        st.subheader("Correla√ß√£o: Pot√™ncia vs Pre√ßo")
        fig, ax = plt.subplots(figsize=(8, 6))
        ax.scatter(df['horsepower'], df['price'], alpha=0.5, edgecolors='k')
        ax.set_xlabel('Pot√™ncia (HP)')
        ax.set_ylabel('Pre√ßo ($)')
        ax.set_title('Rela√ß√£o entre Pot√™ncia e Pre√ßo')
        ax.grid(True, alpha=0.3)
        st.pyplot(fig)

    st.subheader("Estat√≠sticas Descritivas")
    st.dataframe(df[['price', 'horsepower', 'enginesize', 'curbweight', 'citympg', 'highwaympg']].describe())

with tab4:
    st.header("Sobre o Projeto")

    st.markdown("""
    ### Objetivo
    Este sistema utiliza **Machine Learning** para prever pre√ßos de carros baseado em caracter√≠sticas t√©cnicas e de mercado.

    ### Tecnologias Utilizadas
    - **Streamlit:** Interface web interativa
    - **Scikit-Learn:** Biblioteca de Machine Learning
    - **Random Forest:** Algoritmo de ensemble learning
    - **Pandas & NumPy:** Manipula√ß√£o e an√°lise de dados

    ### Dataset
    - **Fonte:** CarPrice Assignment Dataset
    - **Registros:** 205 carros
    - **Features:** 26 caracter√≠sticas t√©cnicas

    ### Melhorias Implementadas
    1. Limpeza de dados (corre√ß√£o de marcas)
    2. Novas features (avg_mpg, power_per_engine, volume, weight_to_power)
    3. Valida√ß√£o com m√∫ltiplas m√©tricas (R¬≤, MAE, RMSE, MAPE)
    4. Visualiza√ß√µes interativas
    5. Interface intuitiva e responsiva
    """)
